<?php 
//108.Магический метод __get
//Применение: свойства только для чтения
//Пусть теперь в нашем классе все свойства приватные:

	class Test
	{
		private $prop1 = 1;
		private $prop2 = 2;
	}

/*Давайте сделаем так, чтобы эти свойства во внешнем мире были доступны только для чтения.
Ранее мы такое уже делали, создавая геттеры для каждого свойства и не создавая сеттеры.
Давайте теперь для решения этой задачи воспользуемся магическим методом __get. Будем возвращать в нем значение запрошенного свойства.
Как это сделать: имя запрошенного свойства попадает в параметр метода __get, в нашем случае $property.
Это значит, что мы можем прочитать свойство, имя которого хранится в переменной, вот так: $this->$property 
(имя свойства будет переменной, то есть с долларом вначале, мы это проходили в предыдущих уроках).
Давайте сделаем описанный метод __get:*/

	class Test
	{
		private $prop1 = 1;
		private $prop2 = 2;
		
		public function __get($property)
		{
			return $this->$property;
		}
	}

//Воспользуемся им для чтения свойств:

	$test = new Test;
	
	echo $test->prop1; // выведет 1
	echo $test->prop2; // выведет 2

//Попытка записать что-то в свойство приведет к ошибке:

	$test = new Test;
	$test->prop1 = 2; // выдаст ошибку

//Это именно то, что нам нужно: свойство можно прочитывать, но нельзя записывать.
//Попытка прочитать несуществующее свойство выдаст ошибку (уровня notice):

	$test = new Test;
	echo $test->prop3; // выдаст ошибку

/*Обратите также внимание на следующий нюанс: когда мы делали свойства только для чтения старым способом, 
то для того, чтобы прочитать свойство, мы использовали метод-геттер.
В новом способе мы будем обращаться именно к свойствам, будто они публичные. Но записать в них не сможем, будто они приватные.*/

//Несуществующее свойство
/*В примере выше мы применяли магию метода __get для отлавливания обращения к приватным свойствам.
На самом деле этот метод также может быть полезен для отлавливания обращений к несуществующим свойствам.
Посмотрим на практическом примере.
Пусть у нас есть класс User с фамилией, именем и отчеством, являющимися публичными свойствами:*/

	class User
	{
		public $surname; // фамилия
		public $name; // имя
		public $patronymic; // отчество
	}
	
	$user = new User;
	
	$user->surname = 'Иванов';
	$user->name = 'Иван';
	$user->patronymic = 'Иванович';

//Давайте сделаем так, чтобы объект класса вел себя так, будто у него также есть свойство fullname, выводящее ФИО юзера:

	$user = new User;
	
	$user->surname = 'Иванов';
	$user->name = 'Иван';
	$user->patronymic = 'Иванович';
	
	// Выведет 'Иванов Иван Иванович':
	echo $user->fullname; // это пока не работает, является нашей целью

//Используем для этого наш магический метод __get:

	class User
	{
		public $surname;
		public $name;
		public $patronymic;
		
		// Используем метод-перехватчик:
		public function __get($property)
		{
			// Если идет обращение к свойству fullname:
			if ($property == 'fullname') {
				return $this->surname . ' ' . $this->name . ' ' . $this->patronymic;
			}
		}
	}

//Проверим:

	$user = new User;
	
	$user->surname = 'Иванов';
	$user->name = 'Иван';
	$user->patronymic = 'Иванович';
	
	echo $user->fullname; // выведет 'Иванов Иван Иванович'

//Получается, что с помощью __get мы создали в классе виртуальное свойство: в классе его нет, но прочитать его можно.
//Кстати, записать в такое свойство будет нельзя, так как в реальности его не существует в нашем классе. То есть это свойство только для чтения.

?>	