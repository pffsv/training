<?php
//28.Работа с регулярными выражениями на PHP
//Функция preg_match

	echo preg_match('#a+#', 'eee aaa bbb').'<br>'; //выведет 1
	//Шаблон поиска такой: буква 'a' один или более раз.

	echo preg_match('#a+#', 'eee aaa aa bbb').'<br>'; //все равно выведет 1
	//Функция все равно вернет один, хотя совпадений на самом деле совпадений два.

	echo preg_match('#a+#', 'eee bbb').'<br>'; //выведет 0
	//Функция ничего не нашла - вернет 0.

	echo preg_match('#^[a-zA-Z-.]+@[a-z]+\.[a-z]{2,3}$#', 'my-mail@mail.ru.').'<br>';
	/*Шаблон поиска такой:
    [a-zA-Z-.]+ маленькие или большие латинские буквы, точка или '-' 1 или более раз, @ потом @,
	[a-z]+ потом маленькие латинские 1 или более раз,
	\. потом точка,
	[a-z]{2,3} потом маленькие латинские два или три раза (ru, by, com и т.п.).
	В результате мы получим 1 - наша строка будет корректным емэйлом.*/

	echo preg_match('#^[a-zA-Z-.]+@[a-z]+\.[a-z]{2,3}$#', 'my-#mail@mail.ru').'<br>';

//Функция preg_match_all
/*Функция preg_match находит только первое совпадение. Чтобы найти все совпадения - 
следует использовать preg_match_all(регулярка, где искать, найденное):*/

	echo preg_match_all('#a+#', 'eee aaa bbb', $m).'<br>'; //выведет 1
    //Шаблон поиска такой: буква 'a' один или более раз.


	echo preg_match_all('#a+#', 'eee aaa aa bbb', $m).'<br>'; //выведет 2
    //Функция нашла все совпадения и вернула 2.

	echo preg_match_all('#a+#', 'eee bbb', $m).'<br>'; //выведет 0
	//Функция ничего не нашла - вернет 0.

//Третий параметр
//Функция preg_match_all имеет третий параметр: туда можно записать переменную, к которую сложатся все найденные совпадения (в виде массива):

	echo preg_match_all('#a+#', 'eee aaa aa bbb a',  $matches).'<br>'; //выведет 3
	var_dump($matches);

	//Выведет массив совпадений:
	[0=>[0=>'aaa', 1=>'aa', 2=>'a']];
    //Обратите внимание на многомерность этого массива! Почему так - об этом в следующем пункте.

//Карманы
//Мы с вами использовали круглые скобки ( ) для группировки, однако они имеют еще одно очень важно применение - используются в качестве карманов.

	echo preg_match_all('#x(a+)x#', 'xax xaax xaaax', $matches).'<br>'; //выведет 3
	var_dump($matches);
	//Шаблон поиска такой: буква 'x', затем 'a' один или более раз, затем буква 'x'.

    //А то, что стоит в ( ), ложится в карман - и занесется в массив $matches:
    $matches=
	[
		0=>[0=>'xax', 1=>'xaax', 2=>'xaaax'], //это найденные подстроки
		1=>[0=>'a', 1=>'aa', 2=>'aaa'], //это содержимое кармана
	];

/*То есть карман - это такой способ хранения части того, что мы ищем. 
Например, мы ищем домены вида domain.ru, но хотим узнать только доменную зону (ru, com и т.п.).*/

	preg_match_all('#[a-z]+\.([a-z]{2,3})#', 'domain.ru site.com hello.by', $matches).'<br>';
	/*[a-z]+ - маленькие буквы один или более раз (domain, site и т.п.) \. - точка ([a-z]{2,3}) - 
	маленькие буквы 2 или 3 раза (ru, com, by, net и т.п.)*/

	//Посмотрим содержимое $matches:
	var_dump($matches);
	[
		0=>[0=>'domain.ru', 1=>'site.com', 2=>'hello.by'],
		1=>[0=>'ru', 1=>'com', 2=>'by'] //это содержимое кармана
	];

//Можно использовать не один карман, а несколько. Положим в первый карман имя домена, а во второй - зону:

	preg_match_all('#([a-z]+)\.([a-z]{2,3})#', 'domain.ru site.com hello.by', $matches); 
	var_dump($matches);
	[
		0=>[0=>'domain.ru', 1=>'site.com', 2=>'hello.by'], //это найденные строки
		1=>[0=>'domain', 1=>'site', 2=>'hello'], //это 1-ый карман
		2=>[0=>'ru', 1=>'com', 2=>'by'], //это 2-ой карман
	];
    //Карманы нумеруются по порядку в регулярке: '#([a-z]+)\.([a-z]{2,3})#' - первые круглые скобки - первый карман, вторые - второй карман и так далее.

//Карманы внутри preg_replace
/*Карманы можно использовать и при работе с функцией preg_replace - то, что мы положим в карман, 
затем может быть использовано во втором параметре: preg_replace(регулярка с карманом, на что заменить, где заменить).
Если мы что-то положим в карман в регулярке, то в параметре 'на что заменить' мы можем обратиться к этому карману так: 
$1 – первый карман, $2 второй карман и так далее*/

/*даны строки вида 'aaa@bbb' - буквы, потом собака, потом буквы. 
Нужно поменять местами буквы до @ и после. В нашем случае из 'aaa@bbb' сделать 'bbb@aaa':*/
	echo preg_replace('#([a-z]+)@([a-z]+)#', '$2@$1', 'a@b aa@bb').'<br>'; //b@a bb@aa

	/*Шаблон поиска такой: маленькие буквы один или более раз (первый карман), 
	собака, и опять маленькие буквы один или более раз (второй карман).
	Шаблон замены такой: мы говорим: замени найденное на $2@$1, где $2 – содержимое второго кармана, а $1 - первого.
	Давайте разберем подстроку 'a@b', что с ней происходит: 'a' ложится в первый карман и доступно как $1, 
	'b' ложится во второй карман и доступно как $2.
	При замене $2@$1 мы говорим: $2 (вставится 'b'), собака @, $1 (вставится 'a').*/

//Карман $0 соответствует всему выражению. Давайте заменим подстроки из букв на них самих с '!' по краям:

	echo preg_replace('#[a-z]+#', '!$0!', 'aaa bbb').'<br>'; //выведет '!aaa! !bbb!'
	/*!$0! - $0 это найденная строка (сначала 'aaa', потом 'bbb'). Мы говорим: замени 'aaa' на ее саму ($0), 
	но с '!' по краям !$0!. И получаем '!aaa!'. Для 'bbb' аналогично.*/

//Карманы внутри регулярки
/*Карманы можно использовать и внутри самой регулярки: \1 – первый карман, \2 – второй, и так далее. 
Разберите следующий пример, чтобы понять, для чего это нужно и как этим пользоваться:*/

	//Найдем две одинаковые буквы подряд и заменим на '!':
	echo preg_replace('#([a-z])\1#', '!', 'aaebbc').'<br>'; //выведет '!e!c'
	/*Как это работает: команда [a-z] ищет букву, при этом найденная буква ложится в карман. 
	Затем в регулярке стоит \1, который говорит, что после первой буквы должно идти содержимое первого кармана (а в нем лежит первая буква).*/
	//Таким образом, мы найдем две идущие подряд одинаковые буквы и заменим на '!'.	

//Несохраняющие скобки
/*К сожалению, скобки ( ) выполняют две функции - группировка символов и функцию кармана. 
А что делать, если нам нужно сгруппировать, но в карман не ложить? Для этого придуманы 
специальные несохраняющие скобки (выделены красным) (?:a+) - они группируют, но не ложат в карман:*/

	echo preg_replace('#(?:ab)+([a-z])#', '!$1!', 'ababx abe'); //выведет '!x! !e!'
	/*Шаблон поиска следующий: 'ab' один или более раз, затем одна буква, которую ложим в карман.
	Шаблон замены: заменим найденное на первый карман, обернутый '!' справа и слева.
	Так как первый карман - это ([a-z]), то в него попадет сначала 'x', а потом 'e'.*/

//А вот если мы вместо несохраняющих скобок возьмем обычные, то первый карман будет (ab):

	echo preg_replace('#(ab)+([a-z])#', '!$1!', 'ababx abe'); //выведет '!ab! !ab!'
	//Обратите внимание: + не размножает карманы - 'abab' превратится в '!', а не '!!'.

//Но мы-то хотели, чтобы в карман попадало не 'ab', а то, что после него. Это будет уже второй карман:

	echo preg_replace('#(ab)+([a-z])#', '!$2!', 'ababx abe'); //выведет '!x! !e!'
	/*Получается немного неудобно - $1 (первый карман) нигде не используется. 
	А начинаем сразу с $2. Чтобы не было таких неудобств - и придуманы скобки (?: ).
	Хотя, если вас это не смущает, - можно их и не использовать.
	Исключение: когда у вас много группировок, а карманов мало - 
	будет неудобно считать все скобки, чтобы понять, что вам нужно $5 и $9, 
	а остальные карманы просто группировка. А если что-то поменяется - 
	то придется все пересчитывать. Тут точно лучше использовать (?: ) для группировки, а ( ) - только для карманов.*/	


?>